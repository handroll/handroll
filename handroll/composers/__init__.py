# Copyright (c) 2014, Matt Layman

import filecmp
import io
import os
import re
import shutil
try:
    from html import escape
except ImportError:
    from cgi import escape

import markdown
from pkg_resources import iter_entry_points
import yaml

from handroll import logger


class Composer(object):
    """Interface for all composers"""

    def compose(self, template, source_file, out_dir):
        """Compose whatever appropriate output is generated by the composer.

        :param template: the string.Template
        :param source_file: the filename of the source
        :param out_dir: the directory to store output
        """
        raise NotImplementedError


class Composers(object):
    """A collection of available composers"""

    def __init__(self):
        self._composers = {}
        self.default_composer = CopyComposer()
        for entry_point in iter_entry_points('handroll.composers'):
            cls = entry_point.load()
            self._composers[entry_point.name] = cls()

    def select_composer_for(self, filename):
        _, ext = os.path.splitext(filename)
        return self._composers.get(ext, self.default_composer)


class CopyComposer(Composer):
    """Copy a source file to the destination.

    ``CopyComposer`` is the default composer for any unrecognized file type.
    The source file will be copied to the output directory unless there is a
    file with an identical name and content already at the destination.
    """

    def compose(self, template, source_file, out_dir):
        """Copy a file to the destination if the file does not exist or was
        modified."""
        filename = os.path.basename(source_file)
        # Do not copy files that are already there unless different.
        destination = os.path.join(out_dir, filename)
        if os.path.exists(destination):
            if filecmp.cmp(source_file, destination):
                # Files are equal. Do nothing.
                logger.info('{0} is the same as {1}. Skipping ...'.format(
                    filename, destination))
                return
            else:
                logger.info('{0} differs from {1} ...'.format(
                    filename, destination))

        logger.info(
            'Copying {0} to {1} ...'.format(filename, out_dir))
        shutil.copy(source_file, out_dir)


class GenericHTMLComposer(Composer):
    """A template class that performs basic handling on a source file

    The title will be extracted from the first line and the remaining source
    lines will be passed to the template method for further processing.
    """

    # A pattern to get source content from a file with YAML front matter.
    yaml_scanner = re.compile(r""".*    # YAML header
                                  ---
                                  .*    # front matter
                                  ---\n
                                  (?P<markup>.*)""",
                              re.DOTALL | re.VERBOSE)

    def compose(self, template, source_file, out_dir):
        """Compose an HTML document by generating HTML from the source
        file, merging it with the template, and write the result to output
        directory."""
        logger.info('Generating HTML for {0} ...'.format(source_file))

        data = self._get_data(source_file)

        # Merge the data with the template and write it to the out directory.
        root, _ = os.path.splitext(os.path.basename(source_file))
        output_file = os.path.join(out_dir, root + '.html')
        with open(output_file, 'wb') as out:
            out.write(template.render(data).encode('utf-8'))
            out.write(b'<!-- handrolled for excellence -->\n')

    def _generate_content(self, source):
        """Generate the content from the provided source data."""
        raise NotImplementedError

    def _get_data(self, source_file):
        """Get data from the source file to pass to the template."""
        data = {}
        with io.open(source_file, 'r', encoding='utf-8') as f:
            # The first line determines whether to look for front matter.
            first = f.readline().strip()
            source = f.read()

            if self._has_frontmatter(first):
                documents = yaml.load_all(source)
                data = next(documents)
                if 'title' in data:
                    data['title'] = escape(data['title'])

                # Don't pass all file content to the composer. Find the markup.
                match = re.search(self.yaml_scanner, source)
                if match:
                    source = match.group('markup')
            else:
                # This is a plain file so pull title from the first line.
                data['title'] = escape(first)

            data['content'] = self._generate_content(source)

        return data

    def _has_frontmatter(self, first_line):
        """Check if the document has any front matter. handroll only supports
        front matter from YAML documents."""
        return first_line.startswith('%YAML')


class MarkdownComposer(GenericHTMLComposer):
    """Compose HTML from Markdown files (``.md``).

    The first line of the file will be used as the ``title`` data for the
    template. All following lines will be converted to HTML and sent to the
    template as the ``content`` data.

    The ``MarkdownComposer`` supports syntax highlighting using Pygments. Code
    can be specified using "fenced code" triple backticks.

    ::

        ```python
        class Foo(object):
            '''This sample code would be highlighted in a Python style.'''
        ```

    Use ``pygmentize`` to create your desired CSS file. Refer to the
    `Pygments documentation <http://pygments.org/docs/>`_ for more information.

    .. code-block:: bash

        $ pygmentize -S default -f html > pygments.css
    """

    EXTENSIONS = [
        'codehilite',
        'fenced_code',
    ]

    def _generate_content(self, source):
        return markdown.markdown(
            source, extensions=self.EXTENSIONS, output_format='html5')
