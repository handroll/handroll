# Copyright (c) 2015, Matt Layman

import filecmp
import os
import shutil
import warnings

from pkg_resources import iter_entry_points

from handroll import logger
from handroll.i18n import _


class Composer(object):
    """Interface for all composers"""

    def compose(self, catalog, source_file, out_dir):
        """Compose whatever appropriate output is generated by the composer.

        :param catalog: the ``TemplateCatalog``
        :param source_file: the filename of the source
        :param out_dir: the directory to store output
        """
        raise NotImplementedError

    @property
    def output_extension(self):
        """Get the extension of the output file generated by this composer."""
        raise NotImplementedError


class Composers(object):
    """A collection of available composers"""

    def __init__(self):
        self._available_composers = {}
        self._composers = {}
        self.default_composer = CopyComposer()

        # pkg_resources emits an annoying message related to security that is
        # completely irritating for an average user to address. Filter it out.
        #
        # For the record, the warning is:
        #
        # pkg_resources.py:991: UserWarning: ~/.python-eggs is writable by
        # group/others and vulnerable to attack when used with
        # get_resource_filename. Consider a more secure location (set with
        # .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
        #
        # handroll assumes a level of trust in whatever is placed in the
        # ``handroll.composers`` entry points.
        warnings.filterwarnings('ignore', '.*get_resource_filename.*')

        for entry_point in iter_entry_points('handroll.composers'):
            cls = entry_point.load()
            self._available_composers[entry_point.name] = cls

    def select_composer_for(self, filename):
        _, ext = os.path.splitext(filename)
        return self._get_composer(ext)

    def _get_composer(self, ext):
        """Get a composer. Lazy load composers for an extension so that an
        individual composer only initializes when a file of its type is found.
        """
        if ext not in self._composers:
            if ext in self._available_composers:
                self._composers[ext] = self._available_composers[ext]()
            else:
                self._composers[ext] = self.default_composer

        return self._composers[ext]


class CopyComposer(Composer):
    """Copy a source file to the destination.

    ``CopyComposer`` is the default composer for any unrecognized file type.
    The source file will be copied to the output directory unless there is a
    file with an identical name and content already at the destination.
    """

    def compose(self, catalog, source_file, out_dir):
        """Copy a file to the destination if the file does not exist or was
        modified."""
        filename = os.path.basename(source_file)
        # Do not copy files that are already there unless different.
        destination = os.path.join(out_dir, filename)
        if os.path.exists(destination):
            if filecmp.cmp(source_file, destination):
                # Files are equal. Do nothing.
                logger.debug(_('Skipping {filename} ... It is the same as '
                               '{destination}.').format(
                    filename=filename, destination=destination))
                return
            else:
                logger.info(
                    _('{filename} differs from {destination} ...').format(
                        filename=filename, destination=destination))

        logger.info(_('Copying {filename} to {out_dir} ...').format(
            filename=filename, out_dir=out_dir))
        shutil.copy(source_file, out_dir)

    @property
    def output_extension(self):
        raise AttributeError(
            'The output extension of the CopyComposer is dependent '
            'on the source file extension. This property should not '
            'be invoked for this composer.')
