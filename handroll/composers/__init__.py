# Copyright (c) 2014, Matt Layman

import filecmp
import io
import os
import shutil
try:
    from html import escape
except ImportError:
    from cgi import escape

import markdown
from pkg_resources import iter_entry_points

from handroll import logger


class Composer(object):
    """Interface for all composers"""

    def compose(self, template, source_file, out_dir):
        """Compose whatever appropriate output is generated by the composer.

        :param template: the string.Template
        :param source_file: the filename of the source
        :param out_dir: the directory to store output
        """
        raise NotImplementedError


class Composers(object):
    """A collection of available composers"""

    def __init__(self):
        self._composers = {}
        self.default_composer = CopyComposer()
        for entry_point in iter_entry_points('handroll.composers'):
            cls = entry_point.load()
            self._composers[entry_point.name] = cls()

    def select_composer_for(self, filename):
        _, ext = os.path.splitext(filename)
        return self._composers.get(ext, self.default_composer)


class CopyComposer(Composer):
    """Copy a source file to the destination.

    ``CopyComposer`` is the default composer for any unrecognized file type.
    The source file will be copied to the output directory unless there is a
    file with an identical name and content already at the destination.
    """

    def compose(self, template, source_file, out_dir):
        """Copy a file to the destination if the file does not exist or was
        modified."""
        filename = os.path.basename(source_file)
        # Do not copy files that are already there unless different.
        destination = os.path.join(out_dir, filename)
        if os.path.exists(destination):
            if filecmp.cmp(source_file, destination):
                # Files are equal. Do nothing.
                logger.info('{0} is the same as {1}. Skipping ...'.format(
                    filename, destination))
                return
            else:
                logger.info('{0} differs from {1} ...'.format(
                    filename, destination))

        logger.info(
            'Copying {0} to {1} ...'.format(filename, out_dir))
        shutil.copy(source_file, out_dir)


class GenericHTMLComposer(Composer):
    """A template class that performs basic handling on a source file

    The title will be extracted from the first line and the remaining source
    lines will be passed to the template method for further processing.
    """

    def compose(self, template, source_file, out_dir):
        """Compose an HTML document by generating HTML from the source
        file, merging it with the template, and write the result to output
        directory."""
        logger.info('Generating HTML for {0} ...'.format(source_file))

        # Read the source to extract the title and content.
        data = {}
        with io.open(source_file, 'r', encoding='utf-8') as f:
            # The title is expected to be on the first line.
            data['title'] = escape(f.readline().strip())
            source = f.read()
            data['content'] = self._generate_content(source)

        # Merge the data with the template and write it to the out directory.
        root, _ = os.path.splitext(os.path.basename(source_file))
        output_file = os.path.join(out_dir, root + '.html')
        with open(output_file, 'wb') as out:
            out.write(template.safe_substitute(data).encode('utf-8'))
            out.write(b'<!-- handrolled for excellence -->\n')

    def _generate_content(self, source):
        """Generate the content from the provided source data."""
        raise NotImplementedError


class MarkdownComposer(GenericHTMLComposer):
    """Compose HTML from Markdown files (``.md``).

    The first line of the file will be used as the ``title`` data for the
    template. All following lines will be converted to HTML and sent to the
    template as the ``content`` data.

    The ``MarkdownComposer`` supports syntax highlighting using Pygments. Code
    can be specified using "fenced code" triple backticks.

    ::

        ```python
        class Foo(object):
            '''This sample code would be highlighted in a Python style.'''
        ```

    Use ``pygmentize`` to create your desired CSS file. Refer to the
    `Pygments documentation <http://pygments.org/docs/>`_ for more information.

    .. code-block:: bash

        $ pygmentize -S default -f html > pygments.css
    """

    EXTENSIONS = [
        'codehilite',
        'fenced_code',
    ]

    def _generate_content(self, source):
        return markdown.markdown(
            source, extensions=self.EXTENSIONS, output_format='html5')
