# Copyright (c) 2016, Matt Layman

import filecmp
import os
import shutil
import warnings

from pkg_resources import iter_entry_points

from handroll import logger
from handroll.i18n import _


class Composer(object):
    """Interface for all composers"""

    def __init__(self, config):
        """Each composer is given the configuration when instantiated."""
        self._config = config

    def compose(self, catalog, source_file, out_dir):
        """Compose whatever appropriate output is generated by the composer.

        :param catalog: the ``TemplateCatalog``
        :param source_file: the filename of the source
        :param out_dir: the directory to store output
        """
        raise NotImplementedError

    def get_output_extension(self, filename):
        """Get the extension of the output file generated by this composer.

        The filename is required because some composers may vary their
        extension based on the filename.
        """
        raise NotImplementedError


class Composers(object):
    """A collection of available composers"""

    def __init__(self, config):
        self._config = config
        self._available_composers = {}
        self._composers = {}
        self.default_composer = CopyComposer(config)

        # pkg_resources emits an annoying message related to security that is
        # completely irritating for an average user to address. Filter it out.
        #
        # For the record, the warning is:
        #
        # pkg_resources.py:991: UserWarning: ~/.python-eggs is writable by
        # group/others and vulnerable to attack when used with
        # get_resource_filename. Consider a more secure location (set with
        # .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
        #
        # handroll assumes a level of trust in whatever is placed in the
        # ``handroll.composers`` entry points.
        warnings.filterwarnings('ignore', '.*get_resource_filename.*')

        for entry_point in iter_entry_points('handroll.composers'):
            cls = entry_point.load()
            self._available_composers[entry_point.name] = cls

    def select_composer_for(self, filename):
        _, ext = os.path.splitext(filename)
        return self._get_composer(ext)

    def _get_composer(self, ext):
        """Get a composer. Lazy load composers for an extension so that an
        individual composer only initializes when a file of its type is found.
        """
        if ext not in self._composers:
            if ext in self._available_composers:
                composer_cls = self._available_composers[ext]
                self._composers[ext] = composer_cls(self._config)
            else:
                self._composers[ext] = self.default_composer

        return self._composers[ext]

    def get_output_extension(self, filename):
        """Get the output extension of a source file."""
        composer = self.select_composer_for(filename)
        return composer.get_output_extension(filename)


class CopyComposer(Composer):
    """Copy a source file to the destination.

    ``CopyComposer`` is the default composer for any unrecognized file type.
    The source file will be copied to the output directory unless there is a
    file with an identical name and content already at the destination.
    """

    def compose(self, catalog, source_file, out_dir):
        """Copy a file to the destination if the file does not exist or was
        modified."""
        filename = os.path.basename(source_file)
        # Do not copy files that are already there unless different.
        destination = os.path.join(out_dir, filename)
        if os.path.exists(destination):
            if (
                not self._config.force and
                filecmp.cmp(source_file, destination)
            ):
                # Files are equal. Do nothing.
                logger.debug(_('Skipping {filename} ... It is the same as '
                               '{destination}.').format(
                    filename=filename, destination=destination))
                return
            else:
                logger.info(
                    _('{filename} differs from {destination} ...').format(
                        filename=filename, destination=destination))

        logger.info(_('Copying {filename} to {out_dir} ...').format(
            filename=filename, out_dir=out_dir))
        shutil.copy(source_file, out_dir)

    def get_output_extension(self, filename):
        _, ext = os.path.splitext(filename)
        return ext
